# 算法

## 斐波那契数列

**后面的值，等于前两个值之和**

斐波那契数列（兔子序列）1、1、2、3、5、8、13，21…

```js
//利用递归函数求:用户输入一个数字n就可以求出这个数字对应的兔子序列值
//我们只需要知道用户输入的n的前面两项（n-1 n-2）就可以计算出n对应的序列值
function fn(n) {
  if (n === 1 || n === 2) {
    return 1;
  }
  return fn(n - 1) + fn(n - 2);
}
console.log(fn(3)); //2
console.log(fn(6)); //8
```

## 递归太多怎么优化

### 一: 时间复杂度的优化

是否重复计算：在递归的过程，很多时候一些子问题是被重复计算的
**优化方法**

- 我们可以将计算的结果保存起来，就可以避免重复进行计算。
- 可以用数组或者是哈希表进行存储，通过查表判断是否有重新计算过，如果有则无需再算。

### 二: 空间复杂度的优化

1. 尾递归
   尾递归，顾名思义，就是在函数体的尾部再进行递归（调用自己）。
2. 在函数体内多次递归

[递归太多怎么优化:参考](https://blog.csdn.net/Mutonix6/article/details/115910658)

## 文档

[参考](https://blog.csdn.net/Better_Xing/article/details/114937915)
